# Overview

Umbrella is a simple library that add the capability of convert an `IEnumerable` instance to a `DataTable`. This saves the time of creating long boilerplate code for define the `DataTable` columns and map your source data into the `DataTable`.

## Installation

...

## Usage

Just import the `Umbrella` namespace in your class, and wherever you have an instance of an `IEnumerable`, you would be able to convert it as a `DataTable`.

````csharp
using Umbrella;

...

public class Order
{
    public long Id {get; set;}
    public string Description {get; set;}
    public decimal Amount {get; set;}
    public decimal Freight {get; set;}
    public bool IsShipped {get; set;}
}

...

List<Order> orders = GetOrders();

DataTable ordersTable = orders.ToDataTable(o => new {ID = o.Id, NetAmount = o.Amount + o.Freight, p.IsShipped});
````

The code snippet above would create a `DataTable` where its columns are `ID`, `NetAmount` and `IsShipped`. The data type of a column is taken from the property's static type binded: the property `Id` is binded to the column `ID`, so the resulting column would have a `long` as data type - actually `BIGINT` in the DBMS side.

Notice the sum operation binded to the `NetAmount` column; that means that the sum of both properties - `Amount` and `Freight` - would be the value listed over that column.

### How it works?

**Umbrella** takes the projection's **Expression Tree** generated by the .NET Compiler in order to generate the `DataTable` metadata: column names, column data types and column constraints - at the moment it supports if the column allows `null` or not -. It also helps in dumping the data from the `IEnumerable` instance into the `DataTable` by creating a *mapper function* that takes as input an `IEnumerable` item and return a new piece of data. 

#### How Columns are inferred?

When projecting objects, you have as input an object of type A and produce an object of type B by executing a function that shapes/transforms the input object into another one. This function in the projection context is an expression and it would be known as **projector**. For example, check the projector below:

````csharp
(Order o) => new {ID = o.Id, o.Description, TotalAmount = o.Amount}
````

From a C# standpoint, we're projecting an object where its properties are `ID`, `Description` and `TotalAmount`. From the `DataTable` standpoint, we're demanding a `DataTable` where its columns are `ID`, `Description` and `TotalAmount` too. So basically **a property within the projection equals to a column**.

*Note: projection means create an object of type A into another of type B (object transformation).*

You have to ensure that your projector outputs an object no matter what, thus you would have properties in hand. There's an exception for this rule, and it's when your input type is already an object and your projector basically projects a member of the object without explicitily creating a new object - without using the `new` operator - . For instance:

````csharp
(Order o) => o.Id
````

The projector above is valid: it demands the creation of a `DataTable` that has a single column: `Id`. However, the projector below is invalid:

````csharp
(int i) => i
````

**Umbrella** can't translate this as a column because it's not even a complex type (it's not an object). It doesn't have state, properties, and so on. In case you want to produce a `DataTable` based on the given collection, then we have to wrap our field into an object by using the `new` operator:

````csharp
(int i) => new {ID = i}
````

Now **Umbrella** sees that it should create a `DataTable` of a single column called `ID`.

*Rule of thumb: if your input type isn't a complex one (an object), then ensure to wrap it as an object by using the `new` operator.*

##### Varieties of projectors (Cheatsheet)

| Projector | Columns Inferred |
| - | - |
| `(Order o) => new {o.Id, o.Description}` | `Id`, `Description`|
| `(Order o) => o` | `Id`, `Description`, `Amount`, `Freight`, `IsShipped` |
| `(Order o) => new Order(){Id = o.Id}` | `Id`|
| `(int i) => new {Identifier = i}` | `Identifier`|

#### How the data is mapped to the `DataTable`?

Notice that the properties encountered in the projector are binded to an expression: either an expression that access the member of the input object, or an arithmethic expression, or a string operation and so on. Each one of these expressions are used to produce the value of a column when iterating over the `IEnumerable` instance: before start looping the collection, it compiles each binded expression as a `Delegate`, thus we end with a map of **Column - Delegate**; this delegate might be *parameterless or not* - depending if the underlying expression reference the projector's input object -, and it's invoked iteratively across all the collection's items. When executing all the delegates for a collection's item we end with a row, which is appended to the `DataTable`.

Let's assume we have the following a set of Orders and we project them as:

````csharp
List<Order> orders = new List<Order>()
{
    new Order(){Id = 1, Description = "BMX", Amount = 24, Freight = 1, IsShipped = false},
    new Order(){Id = 2, Description = "Toyota Corolla", Amount = 2211, Freight = 12, IsShipped = true},
    new Order(){Id = 3, Description = "Yamaha Bike", Amount = 224, Freight = 4, IsShipped = false}
};

DataTable orderTable = orders.ToDataTable(o => new {o.Id, TotalAmount = o.Amount + o.Freight, Processed = true});
````

We would end with a table like this:

| Id | TotalAmount | Processed |
| - | - | - |
| 1 | 25 | true |
| 2 | 2223 | true |
| 3 | 228 | true |

How we ended with the `DataTable` already filled like the one above? We already know how the column discovery works: *each property within the projection represents a column*, but what the values listed below each columns... where they come from? They come from the source collection - the `IEnumerable` instance -, but each value is the output of a function that is already mapped to each column. See the data structure below used by **Umbrella** in order to map a column's mapper function:

| Column | Mapper function *(seems as a lambda expression)* | Description |
| - | - | - |
| `Id` | `(Order o) => o.Id` | Returns the Order's `Id` value |
| `TotalAmount` | `(Order o) => o.Amount + o.Freight` | Returns the sum of Order's `Amount` and `Freight` |
| `Processed` | `() => true` | Always return `true` (notice it's a parameterless function due to it did not reference the projector's input object) |

When dumping the data into the `DataTable`, the mapper function is looked up by the underlying column, and it's executed by passing as parameter - or not - the underlying collection's item.


### Why you would use this library?

The process for create a `DataTable` can be tedious: initialize the table, create the `DataColumn`s by specifying its name and data type, create a `DataRow` per each entry and map the entry's values to the row, and finally append the `DataRow` to the table. This process can be really cumbersome when dealing with a dataset that has numerous columns. That's one of the situations where `Umbrella` takes action: creates `DataTable` with data in it from an `IEnumerable` instance and a .NET projection.

I have seen solutions about how to convert a `List` to a `DataTable` where the generic type of the `List` is reflected in order to fetch its properties and use them as columns for the table. Although this solution might satisfy a bunch of scenarios, you're coupling your underlying type to the table generation. The way `Umbrella` generates the table it's different even though it uses reflection behind of scenes: you project an object that would represent your `DataTable` schema and the values that should be allocated in each column. This approach provides you the control of **what are going to be your columns** and **how your data should be mapped to each column when creating a row**.

For instance, using a projector helps in:

- Infering your column's name - or you can specifiy your own name.
- Having a projector per each column that denotes how the data is mapped from the collection into each column - a mapping expression.
- Infering the column's data type based on the column's projector - or you can specify it by yourself.

The main purpose of writting this library is boost your productivity as Developer and reduce the lines of codes required for manipulate `DataTable`s - which might increase the readibility of your code.

### Tips

...