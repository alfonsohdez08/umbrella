# Overview

Umbrella is a simple library that add the capability of convert an `IEnumerable` instance to a `DataTable`. This saves the time of creating long boilerplate code for define the `DataTable` columns and map your source data into the `DataTable`.

## Installation

## Usage

Just import the `Umbrella` namespace in your class, and wherever you have an instance of an `IEnumerable`, you would be able to convert it as a `DataTable`.

````csharp
using Umbrella;

...

public class Order
{
    public long Id {get; set;}
    public string Description {get; set;}
    public decimal Amount {get; set;}
    public decimal Freight {get; set;}
    public bool IsShipped {get; set;}
}

...

List<Order> orders = GetOrders();

DataTable ordersTable = orders.ToDataTable(o => new {ID = o.Id, NetAmount = o.Amount + o.Freight, p.IsShipped});
````

The code snippet above would create a `DataTable` where its columns are `ID`, `NetAmount` and `IsShipped`. The data type of a column is taken from the property's static type binded: the property `Id` is binded to the column `ID`, so the resulting column would have a `long` as data type - actually `BIGINT` in the DBMS side.

Notice the sum operation binded to the `NetAmount` column; that means that the sum of both properties - `Amount` and `Freight` - would be the value listed over that column.

### How it works?

**Umbrella** takes the projection's **Expression Tree** generated by the .NET Compiler in order to generate the `DataTable` metadata: column names, column data types and column constraints - at the moment it supports if the column allows `null` or not -. It also helps in dumping the data from the `IEnumerable` instance into the `DataTable` by creating a *mapper function* that takes as input an `IEnumerable` item and return a new piece of data. 

#### How Columns are inferred?

When projecting objects, you have as input an object of type A and produce an object of type B by executing a function that shapes/transforms the input object into another one. This function in the projection context is an expression and it would be known as **projector**. For example, check the projector below:

````csharp
(Order o) => new {ID = o.Id, o.Description, TotalAmount = o.Amount}
````

From a C# standpoint, we're projecting an object where its properties are `ID`, `Description` and `TotalAmount`. From the `DataTable` standpoint, we're demanding a `DataTable` where its columns are `ID`, `Description` and `TotalAmount` too. So basically **a property within the projection equals to a column**.

*Note: projection means create an object of type A into another of type B (object transformation).*

You have to ensure that your projector outputs an object no matter what, thus you would have properties in hand. There's an exception for this rule, and it's when your input type is already an object and your projector basically projects a member of the object without explicitily creating a new object - without using the `new` operator - . For instance:

````csharp
(Order o) => o.Id
````

The projector above is valid: it demands the creation of a `DataTable` that has a single column: `Id`. However, the projector below is invalid:

````csharp
(int i) => i
````

**Umbrella** can't translate this as a column because it's not even a complex type (it's not an object). It doesn't have state, properties, and so on. In case you want to produce a `DataTable` based on the given collection, then we have to wrap our field into an object by using the `new` operator:

````csharp
(int i) => new {ID = i}
````

Now **Umbrella** sees that it should create a `DataTable` of a single column called `ID`.

*Rule of thumb: if your input type isn't a complex one (an object), then ensure to wrap it as an object by using the `new` operator.*

##### Varieties of projectors (Cheatsheet)

| Projector | Columns Inferred |
| - | - |
| `(Order o) => new {o.Id, o.Description}` | `Id`, `Description`|
| `(Order o) => o` | `Id`, `Description`, `Amount`, `Freight`, `IsShipped` |
| `(Order o) => new Order(){Id = o.Id}` | `Id`|
| `(int i ) => new {Identifier = i}` | `Identifier`|

#### How the data is mapped to the `DataTable`?

